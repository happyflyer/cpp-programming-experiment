#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    int n; // 三角形行数
    cout << "input n:";
    cin >> n;
    int a[n][n];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            a[i][j] = 0;
    /**
     * 生成杨辉三角
     * 行数下标从0开始，列数下标从0开始
     * 1
     * 1 1
     * 1 2 1
     * 1 3 3 1
     * 1 4 6 4 1
     * ...
     *
     * 首先，第0行和第1行都元素是手动赋值
     * a[0][0] = 1
     * a[1][0] = 1
     * a[1][1] = 1
     * 第2行开始（行号从0开始），对行数i进行循环，每次循环的时候，需要根据不同的列做不同的赋值
     * 第一种情况：a[i][0] = 1
     * 第二种情况：a[i][i] = 1
     * 第三种情况（对所有的j : 1 <= j < i，此处应该还有一个循环）：
     * a[i][j] = a[i - 1][j - 1] + a[i - 1][j]
     *
     * 输出的时候
     * 行循环是：0 <= i < n
     * 列循环是：0 <= j <= i
     *
     * 以上是左杨辉三角
     */
    a[0][0] = 1;
    a[1][0] = 1;
    a[1][1] = 1;
    for (int i = 2; i < n; i++)
    {
        a[i][0] = 1;
        a[i][i] = 1;
        for (int j = 1; j < i; j++)
            a[i][j] = a[i - 1][j - 1] + a[i - 1][j];
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= i; j++)
            cout << setw(3) << a[i][j];
        cout << endl;
    }

    /**
     *  等边杨辉三角只需要把前面的宽度调整好就可以了，其他都是一样的
     *         1
     *       1   1
     *     1   2   1
     *   1   3   3   1
     * 1   4   6   4   1
     * ...
     * 行数i和前面宽度w的关系（此时n=5）
     *   i   w
     *   0   5
     *   1   4
     *   2   3
     *   3   2
     *   4   1
     * 最后行的前面宽度总是1，且我们知道：每行前面宽度肯定与行数i有关系
     * 因此最后一行的前面宽度可以表示为：w = 5-4 = n-i（个单位宽度）
     * 我们需要循环打印出来这些宽度
     * 其实，每行前面的宽度都可以这样表示
     * 也就是说，这是一个通项公式，循环就也可以按照这样写了
     * （写循环之前，要先算清楚通向公式，很重要！！）
     * 值得注意的是，在这个三角形里，这个每行最前面的宽度跟后面元素的宽度不太一样，
     * --1   3   3   1
     * 1---4   6   4   1
     * 好在后面的元素的宽度是固定的，打印的时候注意一下就行
     */
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= i; j++)
            if (j == 0)
                cout << setw(3 * (n - i)) << a[i][j];
            else
                cout << setw(6) << a[i][j];
        cout << endl;
    }

    /**
     * 右杨辉三角的打印，也可以通过调整每行前面的宽度
     *         1
     *       1 1
     *     1 2 1
     *   1 3 3 1
     * 1 4 6 4 1
     * ...
     * 行数i和前面宽度w的关系（此时n=5）
     *   i   w
     *   0   5
     *   1   4
     *   2   3
     *   3   2
     *   4   1
     * 这不是跟上面的关系一样的么
     * 唯一的区别：每行后面元素的宽度不一样
     * --1 3 3 1
     * 1-4 6 4 1
     */
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= i; j++)
            if (j == 0)
                cout << setw(3 * (n - i)) << a[i][j];
            else
                cout << setw(3) << a[i][j];
        cout << endl;
    }

    /**
     * 上面的右杨辉三角，其实是还是用的最开始的那个二维数组（如下）搞出来的
     * 1
     * 1 1
     * 1 2 1
     * 1 3 3 1
     * 1 4 6 4 1
     * ...
     * 当然，也可以真的生成一个这样的数组
     *         1
     *       1 1
     *     1 2 1
     *   1 3 3 1
     * 1 4 6 4 1
     * ...
     * 步骤：
     * 首先，第0行和第1行都是手动赋值
     * a[0][n - 1] = 1
     * a[1][n - 2] = 1
     * a[1][n - 1] = 1
     * 第2行开始（行号从0开始），对行数i进行循环，每次循环的时候，需要根据不同的列做不同的赋值
     * 列循环中有数字的开始位置是：
     *   i   j下标
     *   0   4
     *   1   3
     *   2   2
     *   3   1
     *   4   0
     * 通项是：n - 1 - i
     * 第一种情况：a[i][n - 1 - i] = 1
     * 第二种情况：a[i][n - 1] = 1
     * 第三种情况（对所有的j : n - i <= j < n - 1，此处应该还有一个循环）：
     * a[i][j] = a[i - 1][j] + a[i - 1][j + 1]
     *
     * 生成这样的二维数组二维数组之后
     * 输出的时候，需要注意：
     * 行循环是：0 <= i < n
     * 列循环是：0 <= j < n
     * 列循环还是要j = 0开始循环，因为我们要占宽度
     */
    a[0][n - 1] = 1;
    a[1][n - 2] = 1;
    a[1][n - 1] = 1;
    for (int i = 2; i < n; i++)
    {
        a[i][n - 1 - i] = 1;
        a[i][n - 1] = 1;
        for (int j = n - i; j < n - 1; j++)
            a[i][j] = a[i - 1][j] + a[i - 1][j + 1];
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            if (j < n - 1 - i)
                cout << setw(3) << " ";
            else
                cout << setw(3) << a[i][j];
        cout << endl;
    }

    // 最后，我们打印看下数组a
    cout << "a[" << n << "][" << n << "]:" << endl;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            cout << setw(3) << a[i][j];
        cout << endl;
    }

    system("pause");
    return 0;
}
